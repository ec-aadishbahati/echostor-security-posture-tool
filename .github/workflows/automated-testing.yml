name: Automated Production Testing

on:
  schedule:
    # Weekly on Sundays at 5 PM EST (22:00 UTC during EDT, 21:00 UTC during EST)
    # Note: GitHub Actions cron is UTC-only, so this will shift by 1 hour during DST transitions
    - cron: '0 22 * * 0'
  workflow_dispatch:

jobs:
  test-production:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Playwright and dependencies
        run: |
          pip install playwright pytest-playwright
          playwright install chromium --with-deps

      - name: Run automated production test
        id: test
        run: |
          python3 << 'EOF'
          import asyncio
          import random
          import datetime
          import sys
          import traceback
          import json
          from playwright.async_api import async_playwright, TimeoutError as PlaywrightTimeout

          # Configuration
          PRODUCTION_URL = "https://echostor-security-posture-tool.vercel.app"
          TIMEOUT_NAVIGATION = 30000  # 30 seconds
          TIMEOUT_ACTION = 10000      # 10 seconds
          MAX_RETRIES = 3
          MAX_QUESTIONS = 450  # 409 + buffer to prevent infinite loops

          # Test data
          timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
          test_email = f"test-user-{timestamp}@automated-test.com"
          test_password = "TestPass123!@#"
          test_full_name = "Automated Test User"
          test_company = "Automated Testing Co"

          # Consultation details (200-300 words)
          consultation_text = """
          Our organization is seeking comprehensive cybersecurity consulting services to enhance our security posture. 
          We are a mid-sized enterprise with approximately 500 employees and handle sensitive customer data daily. 
          Our current infrastructure includes cloud-based services, on-premises data centers, and a hybrid work environment.
          
          We have identified several areas where we need expert guidance: improving our incident response capabilities, 
          implementing zero-trust architecture, enhancing our security awareness training programs, and ensuring compliance 
          with industry regulations including GDPR and SOC 2. Additionally, we are interested in conducting penetration 
          testing and vulnerability assessments across our entire infrastructure.
          
          Our budget for this engagement is flexible, and we are looking for a partner who can provide both strategic 
          guidance and hands-on implementation support. We would appreciate a detailed proposal outlining your approach, 
          timeline, and pricing structure. We are particularly interested in understanding how you would help us mature 
          our security operations and establish measurable security metrics. Please contact us at your earliest convenience 
          to discuss our requirements in detail and schedule an initial consultation meeting.
          """

          async def log(message, level="INFO"):
              """Log with timestamp"""
              ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
              print(f"[{ts}] [{level}] {message}", flush=True)

          async def take_screenshot(page, name):
              """Take screenshot for debugging"""
              try:
                  screenshot_path = f"/tmp/screenshot-{name}-{datetime.datetime.now().strftime('%Y%m%d-%H%M%S')}.png"
                  await page.screenshot(path=screenshot_path, full_page=True)
                  await log(f"Screenshot saved: {screenshot_path}")
                  return screenshot_path
              except Exception as e:
                  await log(f"Failed to take screenshot: {str(e)}", "WARNING")
                  return None

          async def main():
              try:
                  await log("=" * 80)
                  await log("Starting Automated Production Test")
                  await log(f"Target: {PRODUCTION_URL}")
                  await log(f"Test User: {test_email}")
                  await log("=" * 80)

                  async with async_playwright() as p:
                      # Launch browser
                      await log("Launching browser...")
                      browser = await p.chromium.launch(headless=True)
                      context = await browser.new_context(
                          viewport={'width': 1920, 'height': 1080},
                          record_video_dir="/tmp/videos/",
                          record_video_size={'width': 1920, 'height': 1080}
                      )
                      
                      # Start tracing for debugging
                      await context.tracing.start(screenshots=True, snapshots=True, sources=True)
                      
                      page = await context.new_page()
                      
                      # Capture console logs and network errors
                      console_logs = []
                      network_errors = []
                      page.on("console", lambda msg: console_logs.append(f"[{msg.type}] {msg.text}"))
                      page.on("requestfailed", lambda request: network_errors.append(
                          f"Failed: {request.method} {request.url} - {request.failure}"
                      ))

                      try:
                          # Step 1: Register new user
                          await log("Step 1: Registering new user...")
                          await page.goto(f"{PRODUCTION_URL}/auth/register", wait_until="networkidle", timeout=TIMEOUT_NAVIGATION)
                          await take_screenshot(page, "01-register-page")

                          # Fill registration form using robust name selectors
                          # Wait for form to be ready
                          await page.locator('input[name="full_name"]').wait_for(state="visible", timeout=TIMEOUT_ACTION)
                          
                          await page.locator('input[name="full_name"]').fill(test_full_name)
                          await page.locator('input[name="email"]').fill(test_email)
                          await page.locator('input[name="company_name"]').fill(test_company)
                          await page.locator('input[name="password"]').fill(test_password)
                          await page.locator('input[name="confirmPassword"]').fill(test_password)
                          
                          await take_screenshot(page, "02-register-filled")
                          
                          # Click "Create account" button
                          register_button = page.locator('button[type="submit"]').first
                          await register_button.click()
                          await page.wait_for_load_state("networkidle", timeout=TIMEOUT_NAVIGATION)
                          await asyncio.sleep(2)
                          await take_screenshot(page, "03-after-register")
                          
                          await log(f"Registration completed. Current URL: {page.url}")

                          # Step 2: Explicitly login to ensure authentication
                          await log("Step 2: Logging in...")
                          await page.goto(f"{PRODUCTION_URL}/auth/login", wait_until="networkidle", timeout=TIMEOUT_NAVIGATION)
                          await take_screenshot(page, "04-login-page")
                          
                          # Fill login form using robust name selectors
                          # Wait for form to be ready
                          await page.locator('input[name="email"]').wait_for(state="visible", timeout=TIMEOUT_ACTION)
                          
                          await page.locator('input[name="email"]').fill(test_email)
                          await page.locator('input[name="password"]').fill(test_password)
                          # Click "Sign in" button
                          login_button = page.locator('button[type="submit"]').first
                          await login_button.click()
                          await page.wait_for_load_state("networkidle", timeout=TIMEOUT_NAVIGATION)
                          await asyncio.sleep(2)
                          await take_screenshot(page, "05-after-login")
                          
                          # Verify authentication
                          cookies = await context.cookies()
                          access_token = next((c for c in cookies if c['name'] == 'access_token'), None)
                          if not access_token:
                              raise AssertionError("Authentication failed: No access_token cookie found")
                          await log("✓ Authentication verified (access_token cookie present)")
                          
                          # Verify we're not on login page
                          if "/auth/login" in page.url:
                              raise AssertionError(f"Still on login page after authentication: {page.url}")
                          await log(f"✓ Redirected away from login page to: {page.url}")

                          # Step 3: Navigate to assessment and start it
                          await log("Step 3: Starting assessment...")
                          await page.goto(f"{PRODUCTION_URL}/assessment/questions", wait_until="networkidle", timeout=TIMEOUT_NAVIGATION)
                          await asyncio.sleep(3)
                          await take_screenshot(page, "06-assessment-page")
                          
                          # Verify we're not redirected to login
                          if "/auth/login" in page.url:
                              raise AssertionError("Redirected to login page - authentication lost")
                          
                          # Look for and click "Start Assessment" button
                          try:
                              start_button = page.get_by_test_id("start-new-assessment")
                              if await start_button.count() > 0:
                                  await log("Found 'Start Assessment' button, clicking...")
                                  await start_button.click(timeout=TIMEOUT_ACTION)
                                  await page.wait_for_load_state("networkidle", timeout=TIMEOUT_NAVIGATION)
                                  await asyncio.sleep(3)
                                  await take_screenshot(page, "07-assessment-started")
                              else:
                                  await log("No start button found, assessment may already be in progress")
                          except Exception as e:
                              await log(f"Error with start button: {str(e)}", "WARNING")
                              await take_screenshot(page, "07-start-button-error")
                          
                          # Verify we see question UI
                          question_text = page.get_by_text("Question", exact=False)
                          if await question_text.count() == 0:
                              raise AssertionError("No question UI found after starting assessment")
                          await log("✓ Assessment UI loaded successfully")

                          # Step 4: Answer all questions one by one
                          await log("Step 4: Answering questions...")
                          await log("This will take approximately 30-45 minutes...")
                          
                          questions_answered = 0
                          last_progress_text = ""
                          stall_count = 0
                          
                          for iteration in range(MAX_QUESTIONS):
                              try:
                                  # Parse progress text to track advancement
                                  try:
                                      progress_elem = page.get_by_text("Assessment Progress:", exact=False)
                                      if await progress_elem.count() > 0:
                                          progress_text = await progress_elem.first.text_content()
                                          if progress_text != last_progress_text:
                                              await log(f"Progress: {progress_text}")
                                              last_progress_text = progress_text
                                              stall_count = 0
                                          else:
                                              stall_count += 1
                                              if stall_count > 5:
                                                  await log("Progress stalled, may have reached end", "WARNING")
                                  except Exception:
                                      pass
                                  
                                  # Check if we've reached the consultation question
                                  consultation_heading = page.get_by_text("Consultation Interest", exact=False)
                                  if await consultation_heading.count() > 0:
                                      await log("Reached consultation question")
                                      break
                                  
                                  # Scope to current question card to avoid clicking wrong elements
                                  question_card = page.locator('div.card').first
                                  if await question_card.count() == 0:
                                      await log("No question card found", "WARNING")
                                      break
                                  
                                  # Look for radio buttons (yes_no and multiple_choice questions)
                                  radio_inputs = question_card.locator('input[type="radio"]')
                                  radio_count = await radio_inputs.count()
                                  
                                  if radio_count > 0:
                                      # Try to select the first unchecked radio with robust fallback sequence
                                      selection_successful = False
                                      for i in range(radio_count):
                                          radio = radio_inputs.nth(i)
                                          if await radio.is_checked():
                                              continue
                                          
                                          await log(f"Attempting to select radio option {i+1}/{radio_count}")
                                          
                                          # Method 1: Use Playwright's check() - designed for form inputs
                                          try:
                                              await radio.scroll_into_view_if_needed()
                                              await radio.check(timeout=TIMEOUT_ACTION)
                                              await asyncio.sleep(0.3)
                                              if await radio.is_checked():
                                                  await log(f"✓ Selected radio option {i+1} via check()")
                                                  selection_successful = True
                                                  break
                                          except Exception as e:
                                              await log(f"check() failed: {str(e)}", "WARNING")
                                          
                                          # Method 2: Focus + Space key + blur (triggers validation)
                                          try:
                                              await radio.focus()
                                              await page.keyboard.press('Space')
                                              await radio.evaluate('el => el.blur()')
                                              await asyncio.sleep(0.3)
                                              if await radio.is_checked():
                                                  await log(f"✓ Selected radio option {i+1} via Space key")
                                                  selection_successful = True
                                                  break
                                          except Exception as e:
                                              await log(f"Space key failed: {str(e)}", "WARNING")
                                          
                                          # Method 3: JavaScript dispatch events (React Hook Form listens to onChange)
                                          try:
                                              await radio.evaluate('''el => {
                                                  el.checked = true;
                                                  el.dispatchEvent(new Event('input', {bubbles: true}));
                                                  el.dispatchEvent(new Event('change', {bubbles: true}));
                                                  el.blur();
                                              }''')
                                              await asyncio.sleep(0.3)
                                              if await radio.is_checked():
                                                  await log(f"✓ Selected radio option {i+1} via JS events")
                                                  selection_successful = True
                                                  break
                                          except Exception as e:
                                              await log(f"JS events failed: {str(e)}", "WARNING")
                                      
                                      if not selection_successful:
                                          await log("Failed to select any radio option after all fallbacks", "WARNING")
                                          await take_screenshot(page, f"radio-selection-failed-{iteration}")
                                  
                                  # Look for checkboxes (multiple_select questions)
                                  checkbox_inputs = question_card.locator('input[type="checkbox"]')
                                  checkbox_count = await checkbox_inputs.count()
                                  
                                  if checkbox_count > 0:
                                      # Randomly select 1-2 checkboxes with robust fallback
                                      num_to_select = random.randint(1, min(2, checkbox_count))
                                      selected_count = 0
                                      for _ in range(num_to_select):
                                          idx = random.randint(0, checkbox_count - 1)
                                          checkbox = checkbox_inputs.nth(idx)
                                          if await checkbox.is_checked():
                                              continue
                                          
                                          # Try check() method first
                                          try:
                                              await checkbox.scroll_into_view_if_needed()
                                              await checkbox.check(timeout=TIMEOUT_ACTION)
                                              await asyncio.sleep(0.2)
                                              if await checkbox.is_checked():
                                                  selected_count += 1
                                          except Exception:
                                              # Fallback: JS events
                                              try:
                                                  await checkbox.evaluate('''el => {
                                                      el.checked = true;
                                                      el.dispatchEvent(new Event('input', {bubbles: true}));
                                                      el.dispatchEvent(new Event('change', {bubbles: true}));
                                                  }''')
                                                  await asyncio.sleep(0.2)
                                                  if await checkbox.is_checked():
                                                      selected_count += 1
                                              except Exception:
                                                  pass
                                      
                                      if selected_count > 0:
                                          await log(f"Selected {selected_count} checkbox option(s)")
                                  
                                  # Wait for Next button to be enabled, then click to advance
                                  try:
                                      # Wait for Next button to be enabled (not disabled)
                                      # This is more reliable than polling is_disabled()
                                      try:
                                          await page.wait_for_selector(
                                              '[data-testid="next-question-btn"]:not([disabled])',
                                              timeout=10000
                                          )
                                          await log("✓ Next button enabled")
                                      except Exception as e:
                                          await log(f"Next button still disabled after 10s: {str(e)}", "WARNING")
                                          await take_screenshot(page, f"next-disabled-{iteration}")
                                          
                                          # Fallback: Try clicking "Save Progress" button
                                          # The UI shows "Not saved yet" - saving might enable Next
                                          try:
                                              await log("Trying Save Progress as fallback...")
                                              save_button = page.locator('[data-testid="save-progress-btn"]')
                                              if await save_button.count() > 0:
                                                  await save_button.click(timeout=TIMEOUT_ACTION)
                                                  await asyncio.sleep(2)
                                                  await log("Clicked Save Progress, waiting for Next to enable...")
                                                  
                                                  # Wait again for Next to be enabled
                                                  await page.wait_for_selector(
                                                      '[data-testid="next-question-btn"]:not([disabled])',
                                                      timeout=5000
                                                  )
                                                  await log("✓ Next button enabled after Save Progress")
                                              else:
                                                  await log("Save Progress button not found", "WARNING")
                                                  raise Exception("Next button never enabled")
                                          except Exception as save_error:
                                              await log(f"Save Progress fallback failed: {str(save_error)}", "WARNING")
                                              raise
                                      
                                      # Click Next button
                                      next_button = page.locator('[data-testid="next-question-btn"]')
                                      await next_button.click(timeout=TIMEOUT_ACTION)
                                      await asyncio.sleep(0.5)
                                      
                                      # Verify progress changed before incrementing counter
                                      await asyncio.sleep(0.5)
                                      try:
                                          progress_elem = page.get_by_text("Assessment Progress:", exact=False)
                                          if await progress_elem.count() > 0:
                                              new_progress = await progress_elem.first.text_content()
                                              if new_progress != last_progress_text:
                                                  questions_answered += 1
                                                  if questions_answered % 10 == 0:
                                                      await log(f"Answered {questions_answered} questions")
                                              else:
                                                  await log("Warning: Progress text didn't change after clicking Next", "WARNING")
                                      except Exception:
                                          # If we can't verify, assume it worked
                                          questions_answered += 1
                                      
                                  except Exception as e:
                                      await log(f"Could not advance to next question: {str(e)}", "WARNING")
                                      await take_screenshot(page, f"next-error-{iteration}")
                                      # May have reached the end
                                      break
                                  
                                  # Take periodic screenshots
                                  if iteration > 0 and iteration % 50 == 0:
                                      await take_screenshot(page, f"progress-{iteration}")
                                  
                              except Exception as e:
                                  await log(f"Error in iteration {iteration}: {str(e)}", "WARNING")
                                  await take_screenshot(page, f"error-iteration-{iteration}")
                                  # Continue to next iteration
                                  continue
                          
                          await log(f"Completed question answering loop. Questions answered: {questions_answered}")
                          await take_screenshot(page, "08-questions-completed")
                          
                          # Verify we answered enough questions
                          if questions_answered < 400:
                              raise AssertionError(f"Only answered {questions_answered} questions, expected at least 400")
                          await log(f"✓ Answered {questions_answered} questions (>= 400 required)")

                          # Step 5: Fill consultation details
                          await log("Step 5: Filling consultation details...")
                          try:
                              # Look for consultation interest radio buttons
                              yes_radio = page.get_by_label("Yes", exact=False).first
                              if await yes_radio.count() > 0:
                                  await yes_radio.click(timeout=TIMEOUT_ACTION)
                                  await log("Selected 'Yes' for consultation interest")
                                  await asyncio.sleep(1)
                              
                              # Fill consultation details textarea
                              textarea = page.locator('textarea')
                              if await textarea.count() > 0:
                                  await textarea.first.fill(consultation_text, timeout=TIMEOUT_ACTION)
                                  word_count = len(consultation_text.split())
                                  await log(f"Filled consultation details ({word_count} words)")
                              
                              await take_screenshot(page, "09-consultation-filled")
                          except Exception as e:
                              await log(f"Could not fill consultation details: {str(e)}", "WARNING")
                              await take_screenshot(page, "09-consultation-error")

                          # Step 6: Complete assessment
                          await log("Step 6: Completing assessment...")
                          try:
                              complete_button = page.get_by_role("button", name="Complete Assessment")
                              if await complete_button.count() == 0:
                                  # Try alternative button texts
                                  complete_button = page.get_by_role("button", name="Submit Assessment")
                              
                              if await complete_button.count() > 0:
                                  await log("Clicking 'Complete Assessment' button...")
                                  await complete_button.click(timeout=TIMEOUT_ACTION)
                                  await asyncio.sleep(2)
                                  
                                  # Handle confirmation dialog
                                  try:
                                      # Playwright's page.on('dialog') would be better, but for simplicity, look for confirm button
                                      await asyncio.sleep(1)
                                      # The confirm() dialog in browser will auto-accept in headless mode
                                  except Exception:
                                      pass
                                  
                                  await page.wait_for_load_state("networkidle", timeout=TIMEOUT_NAVIGATION)
                                  await asyncio.sleep(3)
                                  await take_screenshot(page, "10-assessment-completed")
                                  await log("✓ Assessment completed successfully")
                              else:
                                  raise AssertionError("Could not find 'Complete Assessment' button")
                          except Exception as e:
                              await log(f"Error completing assessment: {str(e)}", "ERROR")
                              await take_screenshot(page, "10-error-completing")
                              raise

                          # Step 7: Verify report generation
                          await log("Step 7: Verifying report generation...")
                          try:
                              # Navigate to reports page
                              await page.goto(f"{PRODUCTION_URL}/reports", wait_until="networkidle", timeout=TIMEOUT_NAVIGATION)
                              await asyncio.sleep(3)
                              await take_screenshot(page, "11-reports-page")
                              
                              # Look for report status - poll for up to 5 minutes
                              report_found = False
                              for i in range(60):  # 60 * 5 seconds = 5 minutes
                                  try:
                                      # Look for status indicators
                                      status_locators = [
                                          page.get_by_text("completed", exact=False),
                                          page.get_by_text("available", exact=False),
                                          page.get_by_text("Download", exact=False),
                                          page.get_by_role("button", name="Download")
                                      ]
                                      
                                      for locator in status_locators:
                                          if await locator.count() > 0:
                                              await log(f"✓ Report found: {await locator.first.text_content()}")
                                              report_found = True
                                              break
                                      
                                      if report_found:
                                          break
                                      
                                      if i < 59:
                                          if i % 12 == 0:  # Log every minute
                                              await log(f"Waiting for report... ({i*5}s elapsed)")
                                          await asyncio.sleep(5)
                                          await page.reload(wait_until="networkidle", timeout=TIMEOUT_NAVIGATION)
                                  except Exception as e:
                                      await log(f"Error checking report status: {str(e)}", "WARNING")
                                      continue
                              
                              if not report_found:
                                  raise AssertionError("Report not found after 5 minutes of polling")
                              
                              await take_screenshot(page, "12-final-reports")
                              await log("✓ Report generation verified")
                          except Exception as e:
                              await log(f"Error verifying report: {str(e)}", "ERROR")
                              await take_screenshot(page, "12-error-verifying-report")
                              raise

                          # Success!
                          await log("=" * 80)
                          await log("✓ ALL TESTS PASSED SUCCESSFULLY!")
                          await log(f"✓ User registered: {test_email}")
                          await log(f"✓ User authenticated successfully")
                          await log(f"✓ Assessment completed: {questions_answered} questions answered")
                          await log(f"✓ Report generated and verified")
                          await log("=" * 80)

                          # Save artifacts
                          if console_logs:
                              with open("/tmp/console-logs.txt", "w") as f:
                                  f.write("\n".join(console_logs))
                              await log(f"Saved {len(console_logs)} console messages")
                          
                          if network_errors:
                              with open("/tmp/network-errors.txt", "w") as f:
                                  f.write("\n".join(network_errors))
                              await log(f"Saved {len(network_errors)} network errors")
                          
                          # Save storage state for debugging
                          storage_state = await context.storage_state()
                          with open("/tmp/storage-state.json", "w") as f:
                              json.dump(storage_state, f, indent=2)
                          await log("Saved storage state (cookies, localStorage)")

                      except Exception as e:
                          await log("=" * 80, "ERROR")
                          await log(f"✗ TEST FAILED: {str(e)}", "ERROR")
                          await log("=" * 80, "ERROR")
                          traceback.print_exc()
                          
                          # Capture failure information
                          await take_screenshot(page, "FAILURE")
                          
                          # Save artifacts
                          if console_logs:
                              with open("/tmp/console-logs.txt", "w") as f:
                                  f.write("\n".join(console_logs))
                          if network_errors:
                              with open("/tmp/network-errors.txt", "w") as f:
                                  f.write("\n".join(network_errors))
                          try:
                              content = await page.content()
                              with open("/tmp/page-content.html", "w") as f:
                                  f.write(content)
                          except Exception:
                              pass
                          
                          # Save storage state
                          try:
                              storage_state = await context.storage_state()
                              with open("/tmp/storage-state.json", "w") as f:
                                  json.dump(storage_state, f, indent=2)
                          except Exception:
                              pass
                          
                          raise
                      finally:
                          # Stop tracing and save
                          try:
                              await context.tracing.stop(path="/tmp/trace.zip")
                              await log("Saved Playwright trace")
                          except Exception as e:
                              await log(f"Could not save trace: {str(e)}", "WARNING")
                          
                          # Close browser
                          await log("Closing browser...")
                          await context.close()
                          await browser.close()

              except Exception as e:
                  await log(f"Fatal error: {str(e)}", "ERROR")
                  traceback.print_exc()
                  sys.exit(1)

          # Run the test
          asyncio.run(main())
          EOF

      - name: Upload screenshots
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-screenshots
          path: /tmp/screenshot-*.png
          retention-days: 7
          if-no-files-found: ignore

      - name: Upload videos
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-videos
          path: /tmp/videos/
          retention-days: 7
          if-no-files-found: ignore

      - name: Upload Playwright trace
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-trace
          path: /tmp/trace.zip
          retention-days: 7
          if-no-files-found: ignore

      - name: Upload console logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: console-logs
          path: /tmp/console-logs.txt
          retention-days: 7
          if-no-files-found: ignore

      - name: Upload network errors
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: network-errors
          path: /tmp/network-errors.txt
          retention-days: 7
          if-no-files-found: ignore

      - name: Upload page content
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: page-content
          path: /tmp/page-content.html
          retention-days: 7
          if-no-files-found: ignore

      - name: Upload storage state
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: storage-state
          path: /tmp/storage-state.json
          retention-days: 7
          if-no-files-found: ignore
