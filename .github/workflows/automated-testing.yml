name: Automated Production Testing

on:
  schedule:
    # Weekly on Sundays at 5 PM EST (22:00 UTC during EDT, 21:00 UTC during EST)
    # Note: GitHub Actions cron is UTC-only, so this will shift by 1 hour during DST transitions
    - cron: '0 22 * * 0'
  workflow_dispatch:

jobs:
  test-production:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Playwright and dependencies
        run: |
          pip install playwright pytest-playwright
          playwright install chromium --with-deps

      - name: Run automated production test
        id: test
        run: |
          python3 << 'EOF'
          import asyncio
          import random
          import datetime
          import sys
          import traceback
          import json
          from playwright.async_api import async_playwright, TimeoutError as PlaywrightTimeout

          # Configuration
          PRODUCTION_URL = "https://echostor-security-posture-tool.vercel.app"
          TIMEOUT_NAVIGATION = 30000  # 30 seconds
          TIMEOUT_ACTION = 10000      # 10 seconds
          MAX_RETRIES = 3
          MAX_QUESTIONS = 450  # 409 + buffer to prevent infinite loops

          # Test data
          timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
          test_email = f"test-user-{timestamp}@automated-test.com"
          test_password = "TestPass123!@#"
          test_full_name = "Automated Test User"
          test_company = "Automated Testing Co"

          # Consultation details (200-300 words)
          consultation_text = """
          Our organization is seeking comprehensive cybersecurity consulting services to enhance our security posture. 
          We are a mid-sized enterprise with approximately 500 employees and handle sensitive customer data daily. 
          Our current infrastructure includes cloud-based services, on-premises data centers, and a hybrid work environment.
          
          We have identified several areas where we need expert guidance: improving our incident response capabilities, 
          implementing zero-trust architecture, enhancing our security awareness training programs, and ensuring compliance 
          with industry regulations including GDPR and SOC 2. Additionally, we are interested in conducting penetration 
          testing and vulnerability assessments across our entire infrastructure.
          
          Our budget for this engagement is flexible, and we are looking for a partner who can provide both strategic 
          guidance and hands-on implementation support. We would appreciate a detailed proposal outlining your approach, 
          timeline, and pricing structure. We are particularly interested in understanding how you would help us mature 
          our security operations and establish measurable security metrics. Please contact us at your earliest convenience 
          to discuss our requirements in detail and schedule an initial consultation meeting.
          """

          async def log(message, level="INFO"):
              """Log with timestamp"""
              ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
              print(f"[{ts}] [{level}] {message}", flush=True)

          async def take_screenshot(page, name):
              """Take screenshot for debugging"""
              try:
                  screenshot_path = f"/tmp/screenshot-{name}-{datetime.datetime.now().strftime('%Y%m%d-%H%M%S')}.png"
                  await page.screenshot(path=screenshot_path, full_page=True)
                  await log(f"Screenshot saved: {screenshot_path}")
                  return screenshot_path
              except Exception as e:
                  await log(f"Failed to take screenshot: {str(e)}", "WARNING")
                  return None

          async def main():
              try:
                  await log("=" * 80)
                  await log("Starting Automated Production Test")
                  await log(f"Target: {PRODUCTION_URL}")
                  await log(f"Test User: {test_email}")
                  await log("=" * 80)

                  async with async_playwright() as p:
                      # Launch browser
                      await log("Launching browser...")
                      browser = await p.chromium.launch(headless=True)
                      context = await browser.new_context(
                          viewport={'width': 1920, 'height': 1080},
                          record_video_dir="/tmp/videos/",
                          record_video_size={'width': 1920, 'height': 1080}
                      )
                      
                      # Start tracing for debugging
                      await context.tracing.start(screenshots=True, snapshots=True, sources=True)
                      
                      page = await context.new_page()
                      
                      # Capture console logs and network errors
                      console_logs = []
                      network_errors = []
                      page.on("console", lambda msg: console_logs.append(f"[{msg.type}] {msg.text}"))
                      page.on("requestfailed", lambda request: network_errors.append(
                          f"Failed: {request.method} {request.url} - {request.failure}"
                      ))

                      try:
                          # Step 1: Register new user
                          await log("Step 1: Registering new user...")
                          await page.goto(f"{PRODUCTION_URL}/auth/register", wait_until="networkidle", timeout=TIMEOUT_NAVIGATION)
                          await take_screenshot(page, "01-register-page")

                          # Fill registration form using robust name selectors
                          # Wait for form to be ready
                          await page.locator('input[name="full_name"]').wait_for(state="visible", timeout=TIMEOUT_ACTION)
                          
                          await page.locator('input[name="full_name"]').fill(test_full_name)
                          await page.locator('input[name="email"]').fill(test_email)
                          await page.locator('input[name="company_name"]').fill(test_company)
                          await page.locator('input[name="password"]').fill(test_password)
                          await page.locator('input[name="confirmPassword"]').fill(test_password)
                          
                          await take_screenshot(page, "02-register-filled")
                          
                          # Click "Create account" button
                          register_button = page.locator('button[type="submit"]').first
                          await register_button.click()
                          await page.wait_for_load_state("networkidle", timeout=TIMEOUT_NAVIGATION)
                          await asyncio.sleep(2)
                          await take_screenshot(page, "03-after-register")
                          
                          await log(f"Registration completed. Current URL: {page.url}")

                          # Step 2: Explicitly login to ensure authentication
                          await log("Step 2: Logging in...")
                          await page.goto(f"{PRODUCTION_URL}/auth/login", wait_until="networkidle", timeout=TIMEOUT_NAVIGATION)
                          await take_screenshot(page, "04-login-page")
                          
                          # Fill login form using robust name selectors
                          # Wait for form to be ready
                          await page.locator('input[name="email"]').wait_for(state="visible", timeout=TIMEOUT_ACTION)
                          
                          await page.locator('input[name="email"]').fill(test_email)
                          await page.locator('input[name="password"]').fill(test_password)
                          # Click "Sign in" button
                          login_button = page.locator('button[type="submit"]').first
                          await login_button.click()
                          await page.wait_for_load_state("networkidle", timeout=TIMEOUT_NAVIGATION)
                          await asyncio.sleep(2)
                          await take_screenshot(page, "05-after-login")
                          
                          # Verify authentication
                          cookies = await context.cookies()
                          access_token = next((c for c in cookies if c['name'] == 'access_token'), None)
                          if not access_token:
                              raise AssertionError("Authentication failed: No access_token cookie found")
                          await log("âœ“ Authentication verified (access_token cookie present)")
                          
                          # Verify we're not on login page
                          if "/auth/login" in page.url:
                              raise AssertionError(f"Still on login page after authentication: {page.url}")
                          await log(f"âœ“ Redirected away from login page to: {page.url}")

                          # Step 3: Navigate to assessment and start it
                          await log("Step 3: Starting assessment...")
                          await page.goto(f"{PRODUCTION_URL}/assessment/questions", wait_until="networkidle", timeout=TIMEOUT_NAVIGATION)
                          await asyncio.sleep(3)
                          await take_screenshot(page, "06-assessment-page")
                          
                          # Verify we're not redirected to login
                          if "/auth/login" in page.url:
                              raise AssertionError("Redirected to login page - authentication lost")
                          
                          # Look for and click "Start Assessment" button
                          try:
                              start_button = page.get_by_test_id("start-new-assessment")
                              if await start_button.count() > 0:
                                  await log("Found 'Start Assessment' button, clicking...")
                                  await start_button.click(timeout=TIMEOUT_ACTION)
                                  await page.wait_for_load_state("networkidle", timeout=TIMEOUT_NAVIGATION)
                                  await asyncio.sleep(3)
                                  await take_screenshot(page, "07-assessment-started")
                              else:
                                  await log("No start button found, assessment may already be in progress")
                          except Exception as e:
                              await log(f"Error with start button: {str(e)}", "WARNING")
                              await take_screenshot(page, "07-start-button-error")
                          
                          # Verify we see question UI
                          question_text = page.get_by_text("Question", exact=False)
                          if await question_text.count() == 0:
                              raise AssertionError("No question UI found after starting assessment")
                          await log("âœ“ Assessment UI loaded successfully")

                          # Step 4: Answer all questions one by one
                          await log("Step 4: Answering questions...")
                          await log("This will take approximately 30-45 minutes...")
                          
                          questions_answered = 0
                          last_progress_text = ""
                          stall_count = 0
                          
                          for iteration in range(MAX_QUESTIONS):
                              try:
                                  # Parse progress text to track advancement
                                  try:
                                      progress_elem = page.get_by_text("Assessment Progress:", exact=False)
                                      if await progress_elem.count() > 0:
                                          progress_text = await progress_elem.first.text_content()
                                          if progress_text != last_progress_text:
                                              await log(f"Progress: {progress_text}")
                                              last_progress_text = progress_text
                                              stall_count = 0
                                          else:
                                              stall_count += 1
                                              if stall_count > 5:
                                                  await log("Progress stalled, may have reached end", "WARNING")
                                  except Exception:
                                      pass
                                  
                                  # Check if we've reached the consultation question
                                  consultation_heading = page.get_by_text("Consultation Interest", exact=False)
                                  if await consultation_heading.count() > 0:
                                      await log("Reached consultation question")
                                      break
                                  
                                  # Look for radio buttons (yes_no and multiple_choice questions)
                                  # Click the label wrapper, not the raw input (inputs are visually hidden)
                                  radio_labels = page.locator('label:has(input[type="radio"])')
                                  radio_count = await radio_labels.count()
                                  
                                  if radio_count > 0:
                                      # Find the first unchecked radio button and click its label
                                      for i in range(radio_count):
                                          label = radio_labels.nth(i)
                                          radio_input = label.locator('input[type="radio"]')
                                          if not await radio_input.is_checked():
                                              # Scroll into view and click the label wrapper
                                              await label.scroll_into_view_if_needed()
                                              await label.click(timeout=TIMEOUT_ACTION)
                                              
                                              # Verify selection took
                                              await asyncio.sleep(0.3)
                                              if await radio_input.is_checked():
                                                  await log(f"Selected radio option {i+1}/{radio_count}")
                                              else:
                                                  await log(f"Warning: Radio selection may not have registered", "WARNING")
                                              break
                                  
                                  # Look for checkboxes (multiple_select questions)
                                  # Click the label wrapper, not the raw input (inputs are visually hidden)
                                  checkbox_labels = page.locator('label:has(input[type="checkbox"])')
                                  checkbox_count = await checkbox_labels.count()
                                  
                                  if checkbox_count > 0:
                                      # Randomly select 1-2 checkboxes
                                      num_to_select = random.randint(1, min(2, checkbox_count))
                                      selected_count = 0
                                      for _ in range(num_to_select):
                                          idx = random.randint(0, checkbox_count - 1)
                                          label = checkbox_labels.nth(idx)
                                          checkbox_input = label.locator('input[type="checkbox"]')
                                          if not await checkbox_input.is_checked():
                                              # Scroll into view and click the label wrapper
                                              await label.scroll_into_view_if_needed()
                                              await label.click(timeout=TIMEOUT_ACTION)
                                              await asyncio.sleep(0.2)
                                              selected_count += 1
                                      if selected_count > 0:
                                          await log(f"Selected {selected_count} checkbox option(s)")
                                  
                                  # Wait for Next button to be enabled, then click to advance
                                  try:
                                      next_button = page.locator('[data-testid="next-question-btn"]')
                                      if await next_button.count() > 0:
                                          # Wait for Next button to be enabled (selection must register first)
                                          try:
                                              await next_button.wait_for(state="visible", timeout=5000)
                                              # Wait for button to be enabled (disabled attribute removed)
                                              for retry in range(10):
                                                  is_disabled = await next_button.is_disabled()
                                                  if not is_disabled:
                                                      break
                                                  if retry < 9:
                                                      await asyncio.sleep(0.5)
                                              
                                              if is_disabled:
                                                  await log("Warning: Next button still disabled after selection", "WARNING")
                                                  await take_screenshot(page, f"next-disabled-{iteration}")
                                                  # Try clicking anyway as fallback
                                              
                                              await next_button.click(timeout=TIMEOUT_ACTION)
                                              await asyncio.sleep(0.5)  # Brief pause for UI update
                                              questions_answered += 1
                                              if questions_answered % 10 == 0:
                                                  await log(f"Answered {questions_answered} questions")
                                          except Exception as e:
                                              await log(f"Error waiting for/clicking Next button: {str(e)}", "WARNING")
                                              raise
                                      else:
                                          # Try alternative button selectors
                                          next_button_alt = page.get_by_role("button", name="Next")
                                          if await next_button_alt.count() > 0:
                                              await next_button_alt.click(timeout=TIMEOUT_ACTION)
                                              await asyncio.sleep(0.5)
                                              questions_answered += 1
                                          else:
                                              await log("Could not find Next button", "WARNING")
                                              break
                                  except Exception as e:
                                      await log(f"Could not advance to next question: {str(e)}", "WARNING")
                                      # May have reached the end
                                      break
                                  
                                  # Take periodic screenshots
                                  if iteration > 0 and iteration % 50 == 0:
                                      await take_screenshot(page, f"progress-{iteration}")
                                  
                              except Exception as e:
                                  await log(f"Error in iteration {iteration}: {str(e)}", "WARNING")
                                  await take_screenshot(page, f"error-iteration-{iteration}")
                                  # Continue to next iteration
                                  continue
                          
                          await log(f"Completed question answering loop. Questions answered: {questions_answered}")
                          await take_screenshot(page, "08-questions-completed")
                          
                          # Verify we answered enough questions
                          if questions_answered < 400:
                              raise AssertionError(f"Only answered {questions_answered} questions, expected at least 400")
                          await log(f"âœ“ Answered {questions_answered} questions (>= 400 required)")

                          # Step 5: Fill consultation details
                          await log("Step 5: Filling consultation details...")
                          try:
                              # Use robust selectors with name/value attributes (not get_by_label which matches many "Yes" on page)
                              yes_radio = page.locator('input[name="consultation"][value="yes"]').first
                              no_radio = page.locator('input[name="consultation"][value="no"]').first
                              
                              # Attempt 1: Use input.check() (most reliable for React forms)
                              try:
                                  await yes_radio.check(timeout=TIMEOUT_ACTION)
                                  await log("Checked consultation 'Yes' via input.check()")
                              except Exception as e:
                                  await log(f"check() failed: {str(e)}", "WARNING")
                                  
                                  # Attempt 2: Keyboard approach (focus + Space + blur)
                                  try:
                                      await yes_radio.focus()
                                      await page.keyboard.press("Space")
                                      await yes_radio.blur()
                                      await log("Checked consultation 'Yes' via keyboard Space")
                                  except Exception as e2:
                                      await log(f"keyboard fallback failed: {str(e2)}", "WARNING")
                                      
                                      # Attempt 3: JavaScript dispatch (last resort)
                                      await page.evaluate("""
                                          (sel) => {
                                              const el = document.querySelector(sel);
                                              if (!el) return;
                                              el.checked = true;
                                              el.dispatchEvent(new Event('input', { bubbles: true }));
                                              el.dispatchEvent(new Event('change', { bubbles: true }));
                                          }
                                      """, 'input[name="consultation"][value="yes"]')
                                      await log("Checked consultation 'Yes' via JS dispatch")
                              
                              await asyncio.sleep(1)
                              
                              # CRITICAL: Verify the selection registered
                              yes_checked = await yes_radio.is_checked()
                              no_checked = await no_radio.is_checked()
                              await log(f"Consultation radio states: yes_checked={yes_checked}, no_checked={no_checked}")
                              
                              if not yes_checked:
                                  await take_screenshot(page, "09-consultation-yes-not-checked")
                                  raise AssertionError("Consultation 'Yes' radio did not register selection")
                              
                              # Wait for consultation textarea to appear (it only shows when "Yes" is selected)
                              await log("Waiting for consultation textarea to appear...")
                              try:
                                  await page.wait_for_selector('textarea', state='visible', timeout=10000)
                                  await log("âœ“ Consultation textarea is visible")
                              except Exception as e:
                                  await take_screenshot(page, "09-textarea-not-visible")
                                  raise AssertionError(f"Consultation textarea did not appear after selecting 'Yes': {str(e)}")
                              
                              # Fill consultation details textarea
                              textarea = page.locator('textarea').first
                              await textarea.fill(consultation_text, timeout=TIMEOUT_ACTION)
                              word_count = len(consultation_text.split())
                              await log(f"Filled consultation details ({word_count} words)")
                              
                              # CRITICAL: Blur the textarea to trigger validation
                              await textarea.blur()
                              await log("Blurred textarea to trigger validation")
                              await asyncio.sleep(1)
                              
                              await take_screenshot(page, "09-consultation-filled")
                          except Exception as e:
                              await log(f"Could not fill consultation details: {str(e)}", "ERROR")
                              await take_screenshot(page, "09-consultation-error")
                              raise

                          # Step 6: Complete assessment
                          await log("Step 6: Completing assessment...")
                          try:
                              # Use robust selector with data-testid
                              complete_button = page.locator('[data-testid="complete-assessment-btn"]')
                              
                              # If data-testid not found, fallback to role-based selector
                              if await complete_button.count() == 0:
                                  await log("data-testid not found, trying role-based selector")
                                  complete_button = page.get_by_role("button", name="Complete Assessment")
                              
                              if await complete_button.count() == 0:
                                  raise AssertionError("Could not find 'Complete Assessment' button")
                              
                              # Use .last() in case there are multiple matches
                              complete_button = complete_button.last
                              
                              # Log button state before clicking
                              try:
                                  is_visible = await complete_button.is_visible()
                                  is_enabled = await complete_button.is_enabled()
                                  is_disabled = await complete_button.get_attribute("disabled")
                                  button_classes = await complete_button.get_attribute("class")
                                  await log(f"Button state: visible={is_visible}, enabled={is_enabled}, disabled_attr={is_disabled}")
                                  await log(f"Button classes: {button_classes}")
                              except Exception as e:
                                  await log(f"Could not check button state: {str(e)}", "WARNING")
                              
                              # Wait for button to be enabled (not just visible)
                              await log("Waiting for Complete Assessment button to be enabled...")
                              max_wait_seconds = 30
                              button_enabled = False
                              for i in range(max_wait_seconds):
                                  try:
                                      if await complete_button.is_enabled():
                                          button_enabled = True
                                          await log(f"âœ“ Button enabled after {i} seconds")
                                          break
                                  except Exception:
                                      pass
                                  
                                  if i < max_wait_seconds - 1:
                                      await asyncio.sleep(1)
                              
                              if not button_enabled:
                                  # Try clicking Save Progress button to trigger validation
                                  await log("Button still disabled, trying Save Progress button...")
                                  try:
                                      save_button = page.locator('[data-testid="save-progress-btn"]')
                                      if await save_button.count() == 0:
                                          save_button = page.get_by_role("button", name="Save Progress")
                                      
                                      if await save_button.count() > 0:
                                          await save_button.first.click(timeout=TIMEOUT_ACTION)
                                          await log("Clicked Save Progress button")
                                          await page.wait_for_load_state("networkidle", timeout=TIMEOUT_NAVIGATION)
                                          await asyncio.sleep(2)
                                          
                                          # Check button state again
                                          if await complete_button.is_enabled():
                                              button_enabled = True
                                              await log("âœ“ Button enabled after Save Progress")
                                  except Exception as e:
                                      await log(f"Could not click Save Progress: {str(e)}", "WARNING")
                              
                              if not button_enabled:
                                  await take_screenshot(page, "10-button-still-disabled")
                                  raise AssertionError("Complete Assessment button is still disabled after 30 seconds")
                              
                              # Scroll button into view
                              await complete_button.scroll_into_view_if_needed()
                              await log("Scrolled button into view")
                              
                              # Click the button with dialog handling
                              await log("Clicking 'Complete Assessment' button...")
                              
                              # Handle confirmation dialog if present
                              dialog_handled = False
                              async def handle_dialog(dialog):
                                  nonlocal dialog_handled
                                  await log(f"Dialog appeared: {dialog.message}")
                                  await dialog.accept()
                                  dialog_handled = True
                                  await log("Accepted confirmation dialog")
                              
                              page.on("dialog", handle_dialog)
                              
                              try:
                                  await complete_button.click(timeout=TIMEOUT_ACTION)
                                  await asyncio.sleep(2)
                                  
                                  if dialog_handled:
                                      await log("âœ“ Confirmation dialog was handled")
                                  
                                  await page.wait_for_load_state("networkidle", timeout=TIMEOUT_NAVIGATION)
                                  await asyncio.sleep(3)
                                  await take_screenshot(page, "10-assessment-completed")
                                  await log("âœ“ Assessment completed successfully")
                              finally:
                                  page.remove_listener("dialog", handle_dialog)
                              
                          except Exception as e:
                              await log(f"Error completing assessment: {str(e)}", "ERROR")
                              await take_screenshot(page, "10-error-completing")
                              raise

                          # Step 7: Verify report generation
                          await log("Step 7: Verifying report generation...")
                          try:
                              # Navigate to reports page
                              await page.goto(f"{PRODUCTION_URL}/reports", wait_until="networkidle", timeout=TIMEOUT_NAVIGATION)
                              await asyncio.sleep(3)
                              await take_screenshot(page, "11-reports-page")
                              
                              # Look for report status - poll for up to 5 minutes
                              report_found = False
                              for i in range(60):  # 60 * 5 seconds = 5 minutes
                                  try:
                                      # Look for status indicators
                                      status_locators = [
                                          page.get_by_text("completed", exact=False),
                                          page.get_by_text("available", exact=False),
                                          page.get_by_text("Download", exact=False),
                                          page.get_by_role("button", name="Download")
                                      ]
                                      
                                      for locator in status_locators:
                                          if await locator.count() > 0:
                                              await log(f"âœ“ Report found: {await locator.first.text_content()}")
                                              report_found = True
                                              break
                                      
                                      if report_found:
                                          break
                                      
                                      if i < 59:
                                          if i % 12 == 0:  # Log every minute
                                              await log(f"Waiting for report... ({i*5}s elapsed)")
                                          await asyncio.sleep(5)
                                          await page.reload(wait_until="networkidle", timeout=TIMEOUT_NAVIGATION)
                                  except Exception as e:
                                      await log(f"Error checking report status: {str(e)}", "WARNING")
                                      continue
                              
                              if not report_found:
                                  raise AssertionError("Report not found after 5 minutes of polling")
                              
                              await take_screenshot(page, "12-final-reports")
                              await log("âœ“ Report generation verified")
                          except Exception as e:
                              await log(f"Error verifying report: {str(e)}", "ERROR")
                              await take_screenshot(page, "12-error-verifying-report")
                              raise

                          # Success!
                          await log("=" * 80)
                          await log("âœ“ ALL TESTS PASSED SUCCESSFULLY!")
                          await log(f"âœ“ User registered: {test_email}")
                          await log(f"âœ“ User authenticated successfully")
                          await log(f"âœ“ Assessment completed: {questions_answered} questions answered")
                          await log(f"âœ“ Report generated and verified")
                          await log("=" * 80)
                          await log("ðŸ“‹ TEST CREDENTIALS SUMMARY:")
                          await log(f"   Email: {test_email}")
                          await log(f"   Password: {test_password}")
                          await log("=" * 80)

                          # Save artifacts
                          if console_logs:
                              with open("/tmp/console-logs.txt", "w") as f:
                                  f.write("\n".join(console_logs))
                              await log(f"Saved {len(console_logs)} console messages")
                          
                          if network_errors:
                              with open("/tmp/network-errors.txt", "w") as f:
                                  f.write("\n".join(network_errors))
                              await log(f"Saved {len(network_errors)} network errors")
                          
                          # Save storage state for debugging
                          storage_state = await context.storage_state()
                          with open("/tmp/storage-state.json", "w") as f:
                              json.dump(storage_state, f, indent=2)
                          await log("Saved storage state (cookies, localStorage)")

                      except Exception as e:
                          await log("=" * 80, "ERROR")
                          await log(f"âœ— TEST FAILED: {str(e)}", "ERROR")
                          await log("=" * 80, "ERROR")
                          traceback.print_exc()
                          
                          # Capture failure information
                          await take_screenshot(page, "FAILURE")
                          
                          # Save artifacts
                          if console_logs:
                              with open("/tmp/console-logs.txt", "w") as f:
                                  f.write("\n".join(console_logs))
                          if network_errors:
                              with open("/tmp/network-errors.txt", "w") as f:
                                  f.write("\n".join(network_errors))
                          try:
                              content = await page.content()
                              with open("/tmp/page-content.html", "w") as f:
                                  f.write(content)
                          except Exception:
                              pass
                          
                          # Save storage state
                          try:
                              storage_state = await context.storage_state()
                              with open("/tmp/storage-state.json", "w") as f:
                                  json.dump(storage_state, f, indent=2)
                          except Exception:
                              pass
                          
                          raise
                      finally:
                          # Stop tracing and save
                          try:
                              await context.tracing.stop(path="/tmp/trace.zip")
                              await log("Saved Playwright trace")
                          except Exception as e:
                              await log(f"Could not save trace: {str(e)}", "WARNING")
                          
                          # Close browser
                          await log("Closing browser...")
                          await context.close()
                          await browser.close()

              except Exception as e:
                  await log(f"Fatal error: {str(e)}", "ERROR")
                  traceback.print_exc()
                  sys.exit(1)

          # Run the test
          asyncio.run(main())
          EOF

      - name: Upload screenshots
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-screenshots
          path: /tmp/screenshot-*.png
          retention-days: 7
          if-no-files-found: ignore

      - name: Upload videos
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-videos
          path: /tmp/videos/
          retention-days: 7
          if-no-files-found: ignore

      - name: Upload Playwright trace
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-trace
          path: /tmp/trace.zip
          retention-days: 7
          if-no-files-found: ignore

      - name: Upload console logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: console-logs
          path: /tmp/console-logs.txt
          retention-days: 7
          if-no-files-found: ignore

      - name: Upload network errors
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: network-errors
          path: /tmp/network-errors.txt
          retention-days: 7
          if-no-files-found: ignore

      - name: Upload page content
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: page-content
          path: /tmp/page-content.html
          retention-days: 7
          if-no-files-found: ignore

      - name: Upload storage state
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: storage-state
          path: /tmp/storage-state.json
          retention-days: 7
          if-no-files-found: ignore
